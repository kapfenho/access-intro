%!TEX root =  main.tex

\chapter{Access Manager}

\section{Overview}

You can think of Access Manager as a general gate, in front of all your
applications, that each request has to pass. It ensures that only
authenticated requests are allowed to pass to the business application
that you are protecting.

For public accessible areas the authentication check is disabled. In
addition you can also skip auditing in this area, if the data would not
be used anyway.

The session of an authenticated user defines the access and is protected 
agains external changes. The \emph{ticket} or the \emph{single sign on 
session} is stored central as well on the client (using cookies).\\*

The boundaries of the single-sign-on session can be defined by domain
and subdomain namespaces. Of course this will only be enforced for
integrated applications.

Each session has set a general time-out and an inactivity time-out. The
general time out will close the session and force a reauthentication, no
matter if there is currently any activity ongoing or not. Default value
of this general time-out is 24 hours. The inactivity time-out is set to
a shorter period, depending on the customer needs and security level.

Integrated applications often require an application session as well,
where user data is attached to. This session information is not touched 
by Access Manager.\\*


The integration of an application is relative simple exercise, since we
essentially remove functionality and code. In particular the login and
logout functionality is removed. Instead of returning an application
login page, the application can take the attached information like user
name, user ID, or roles, and continue with the transaction.

The logout link or button of the business application will remain on the
user interface. The business application will just redirect the user to
the general logout URI, which will trigger the necessary logout
callbacks to the used business applications. So the user sessions will
savely be closed on a general logout. However, as before this is
triggered when the user actively executes a logout.\\*

The individual implementations of the user login and logout are removed
from applications during integration. Only authenticated requests can
reach the application from now on. While an authorization policy
enforcement is available and recommended, other products of the suite
may be necessary to cover different authorization requirements.


\subsection{Use Cases}

Let's make one assumption --- to simplify our examples: the applications
we are dealing with are web applications, to be more exact: the user
interface is rendered in a standard conform Internet browser.\\*

There are ways to integrate legacy applications, however more analysis
work has to be done beforehand.\\*

For web applications, the transport and integration protocol Access
Management uses is HTTP{(S)}. Before our integration, the business
application acts a as a stand-alone application, in respect of the user
session. An application login page is presented to the user, in case the
the that user has no active session. After some work done in the system
the user may log out or the session runs in a time out (usually most of
the user sessions end with time-outs). Both session related actions,
login and logout are under control of the business application.\\*

The implementation of the login functionality is a critical area in
several dimensions:

\begin{itemize}
    \item run time errors may block the whole business application
    \item often an external system call is needed, the response data 
        and its interpretation is not obvious or may change over time
    \item accounts may be locked in different ways, what shall be the 
        user error message?
    \item the business application (perhaps a 3rd party application) 
        needs to deal with user passwords
\end{itemize}

Dealing with all those challenges, a centralized solution like a
directory server, feels again like a redundant and error prone approach.
Quite often it also becomes a dangerous approach, when one of the
business applications or an operational tool is lacking the last
encryption method and sends plain text or it logs one attribute more
then it should (yes login credentials is not an uncommon problem).







\emph{User opens resource (URI) to start a system transaction}

So our start point is a user request for a resource, let's say a the first webpage of a customer maintenance workflow. The webpage is the resource the user requests. Our hypothetical system feature has two UI screens:

\begin{itemize}
    \item Customer search by account id
    \item Customer details screen
\end{itemize}

Access Management's webgate component is attached to the reverse proxy of the business application and inspects every request. The inspection starts like this:

New request 

\chapter{Components of Access Manager}

\section{Certificate Validation and Revocation}

\section{Identity Store}

\section{Session Store}

\section{Agents}

\section{WebGate}

\section{Application Domains and Resources}

\section{SSO Cookies}

\section{Credential Collectors}



\chapter{Sample Configuration}

% vi:set lbr breakindent:
