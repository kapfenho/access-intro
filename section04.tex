%!TEX root =  main.tex

\chapter{Access Manager}


\section{Overview}

The role of Access Manager can be described as a gate keeper, in front
of all business applications. Each user request needs to pass this gate
keeper. It ensures that only authenticated requests are allowed to reach
the protected business application.

\begin{framed}

    All integration practices described are considering the integration
    of web applications. Web applications are applications that deliver 
    the user interface via HTTP or HTTPS\@.

\end{framed}

Access Manager delivers a common used, central login functionality, the
user authentication. The authentication method presented to the user is
determined based on several input parameter, like the resource the user
tries to access, the date and time, perhaps the user location or device
used, or the type of user access manager recognizes already
before the authentication.

The implementation of login functionality is per se critical and it is
critical in multiple ways:

\begin{itemize}

    \item run time errors may block the whole business application

    \item often an external system call is needed, the response data 
        and its interpretation is not obvious or may change over time

    \item accounts may be locked in different ways, what shall be the 
        user error message?

    \item the business application (perhaps a closed source 3rd party
        application) needs to deal with user passwords

\end{itemize}

Dealing with all those challenges, a centralized solution like a
directory server, feels again like a redundant and error prone approach.
Quite often it also becomes a dangerous approach, when one of the
business applications or an operational tool is lacking the latest and
mandatory encryption cipher and now sends plain text or it logs one
attribute more than it should (yes, credentials in log files is not an
uncommon problem).


But not all application areas may trigger an authentication.  For public
accessible areas the authentication check can be disabled in the
\emph{application domain} configuration. In addition auditing records
can be disabled for public accessible area.  This prevents data
collections of no usage or even prohibited usage.

The single-sign-on session of an authenticated user includes its current
authentication level.  We can perceive the session as an \emph{ticket}
to the systems behind the gate keeper.  This ticket is stored central on
the access server and also on the client (using cookies, protected
against external changes). This authentication level is matched the
minimum authentication level attached to the resource the user requests.

The boundaries of the single-sign-on session can be defined by domain
and subdomain namespaces. However this will only be enforced for
integrated applications.

Each session has set a \emph{general time-out} and an \emph{inactivity
time-out}. The general time out will close the session and force a
re-authentication, no matter if there is currently any activity ongoing
or not. Default value of this general time-out is 24 hours. The
inactivity time-out is set to a shorter period, depending on the
customer needs and security level.


\section{Application Integration}

Business applications often require an independent application session,
where user data is attached to. This session information is not touched
by Access Manager.

Before our integration, the business application did act a as a
stand-alone application, in terms of the user session. An application
login page was presented to the user, in case the user had no active
session.

The \emph{integration} of an application is relative simple exercise,
since we essentially remove functionality and code. In particular the
login and logout functionality is removed. Instead of returning an
application login page, the application can take the attached
information like user name, user ID, or roles, and continue with the
transaction.

The logout link or button of the business application will remain on the
user interface. The business application will just redirect the user to
the general logout URI, which will trigger the necessary logout
callbacks to the used business applications. So the user sessions will
safely be closed on a general logout. However, as before this is
triggered when the user actively executes a logout.

The individual implementations of the user login and logout are removed
from applications during integration. Only authenticated requests can
reach the application from now on. While an authorization policy
enforcement is available and recommended, other products of the suite
may be necessary to cover different authorization requirements.



% ====================================================================

\chapter{Components of Access Manager}

In the following pages I will explain what parts or topics Access
Manager consists of and what the are good for:

\begin{itemize}
    \item Access Server
    \item Application Domains and Resources
    \item Identity Store
    \item Session Store
    \item Policy Enforcement Points: Agents
    \item Webgate Agent
    \item SSO Cookies
    \item Credential Collector
    \item Certificate Validation and Revocation
\end{itemize}




\section{Access Server}

The Access Server is the \emph{backend runtime component} that serves
requests of the \emph{Policy Enforcement Points}. It is implemented as
J2EE service and Oracle supports Oracle WebLogic and IBM WebSphere as
application servers. In WebLogic the services are deployed to one or
more managed servers grouped in a WebLogic cluster.  Most of the
interfaces and protocols are based on open standards, an exception here
is the proprietary protocol to the policy enforcement points, called OAP
(Oracle Access Protocol).

The configuration can be done using the web user interface 
\emph{OAMConsole}, hosted on the WebLogic Admin Server. Many features
can also be configured using shell scripts or the WebLogic scripting
environment WLST\@. The substantial configuration is persisted as XML
file. Bindings and policies are stored in the relational database base
schema.


\section{Application Domains and Resources}

The value of an production access system, comes from the integrated
business applications. Therefore the management of those business
applications and their policies is a central area in Access Manager.

Applications are mapped to application domains. This mapping can be done  
as an one-to-one relation, but also other transformations are possible,
as long as it helps the operational team to treat the integration as one
consistent block of applications, which is integrated or maintained at
once.

Each application domain consists of multiple resources. A resource can
be seen as an entitlement in the application domain. Since all resources
are expressed as \emph{Uniform Resource Identifier (URI)}, Access
Management uses the URI component \emph{path} and optionally \emph{query} and
\emph{fragment} as resource identifier.

Example resource identifier: \verb|/orders/**|



\section{Identity Store}

To execute the main feature of Access Manager, the authentication, we
need at least one set of identities that are allowed to authenticate.
This set must be stored in a supported directory server and should be
\emph{close} to Access Manager, in operational and data ownership
perspective.

Access Manager will read from and write to this identity store. The
required initial information in the store is the user login and some
status information of the user account.

Access Manager stores additional runtime data attached to the user
information.

Optional information that can be stored in the identity store can be
\emph{user credentials}, \emph{user roles}, etc.

In case you deploy \emph{Access Manager} with \emph{Oracle Identity
Manager} the directory is automatically populated and acts as a data hub
between Identity and Access Management.


\section{Session Store}

We already mentioned where user sessions are stored. But let's have a
closer look here.

For Access Manager it is essential to have clear accounting of active
user sessions, with additional information attached to them:

\begin{itemize}
    \item when did the session start
    \item timestamps used for time-outs
    \item authentication method used
    \item current and original authentication levels
    \item reference to identity store
    \item location (if applicable)
\end{itemize}

This information must be served quickly with high availability
requirements. Access Manager maintains this list in Coherence.

\begin{framed}

    Oracle Coherence is a proprietary in-memory data grid, that improves
    performance, scalability and reliability compared to relational
    databases. It can be used as an persistence system or as a caching
    method in combination to relational database system.
    
    Coherence was developed by \emph{Tangosol Inc.}, which was acquired 
    by Oracle Corporation in 2007. Several Oracle applications, like 
    Access Manager or SOA, use Coherence.

\end{framed}

The Access Manager admin interface \emph{oamconsole} comes with a
feature for querying and maintaining the session list.

The session information placed at the client side is described in the
section Cookies.


\section{Policy Enforcement Points: Agents}

The Policy Enforcement Points (PEP) are the components actively asking
Access Manager for user access and are enforcing this policy. They act
as gatekeeper to the business applications. One agent implementation is
shipped with the Access Manager Suite, other Oracle implementations are
available but are considered deprecated. Furthermore individual
implementations are supported.

To fulfill its work as gatekeeper a PEP has to be involved in every
client request to the business application, preferably very early in the
request processing to protect the application from different types of
attacks.

For web applications this is usually done in the \emph{demilitarized zone
(DMZ)}, on an perhaps already existing \emph{reverse proxy}.

For incoming request those attributes are evaluated:

\begin{itemize}
    \item requested resource (URI): host and path
    \item existing cookies
    \item misc.\ attributes, like location, etc.
    \item verification data from access server
\end{itemize}

Since there is no policy information stored in distributed locations,
where PEP are deployed, those information must be gathered from the
access server.  This information is heavily cached in the PEP, to speed
up decision response time and throughput.

Possible outcomes of the decision are:

\begin{itemize}
    \item redirect to credential collector
    \item let request pass with audit entry
    \item let request pass without audit entry
\end{itemize}

The communication to the Access Server is crucial and must be protected
against attacks. Access Manager and the PEP implementation can be
configured to use a general encryption key (this is the default setting)
or agent instance related keys.


\section{Webgate Agent}

The Webgate Agent is a Policy Enforcement Point implementation to deploy
on HTTP Servers like \emph{Oracle Web Server} or the \emph{Apache
HTTPD}.\footnote{There has been a version available for Microsoft
    Internet Information Server (IIS). This versions was seemed to be outdated
    and the author was not able to install this binary successfully.
    Since reverse proxies based on Windows are not widely used, I would
not expect further development in this area.} It is shipped as a binary,
compiled for the main platforms, and is integrated as a module for the
web server. No additional run time process is necessary.

The necessary configuration is done inside the HTTPD configuration file
and a general setup with its own configuration file. The communication
channel to the Access Server is protected by certificates located in
configuration directory. There are two types of protection:

\begin{itemize}
    \item protecting all agents with the same key
    \item protecting each agent with an individual key
\end{itemize}

The standard HTTPD configuration defines which requests are covered by
Webgate.  For not included resources Webgate and Access Manager are not
involved at all.  For covered resources the decision outcome may also be
\emph{public available}, however the resource must be known to Access
Manager, otherwise an error will be returned to the user.

Agents can be configured with a broad range of log options. Those logs
are stored on the reverse proxy and are not to be confused with the
central stored audit logs. Particular care is recommended to not include 
sensitive request payload information in the log files.


\section{SSO Cookies}

Within the area of Access Manager nine different types of HTTP cookies
are used. Typically three or four cookies are in use in one setup,
if legacy support is needed. Those cookies are automatically encrypted
or signed by the server components.

The \emph{Oracle Fusion Middleware Administrator's Guide for Oracle Access
Management} contains the exhausted list of nine types and description
under what circumstances each type is deployed.



\section{Credential Collectors}

Credential Collectors are web sites with an embedded form, requesting a
user identifier and  credentials to authenticate. The user is redirected
to a credential collector, because he requested a resource and his
current authentication level is lower than required for accessing the
requested resource. To access the resource an certain authentication is
necessary and the user is required to do so. During the authentication
process the original request shall not be lost, otherwise the user would
perhaps authenticate successfully but not get the resource he asked for.
Therefore the request data is dragged along the whole process.

There are two types of credential collectors:

\begin{description}

    \item[Embedded Credential Collector (ECC)] Located in 
        WebLogic managed server of Access Manager. The ECC is shipped
        with the product, customization possibilities are limited.

    \item[Detached Credential Collector (DCC)] Located outside 
        Access Manager, preferably in the DMZ\@. No Java application
        server needed. A \emph{Perl} implementation as sample code is 
        included with product.

\end{description}

The main difference is the location in the network architecture and the
security consequences of this decision. While the usage of ECC allow 
unauthenticated requests to reach application tier, DCC terminates all
unauthenticated requests already in the DMZ\@. 



\section{Certificate Validation and Revocation}

This module delivers standard services for a \emph{Private Key
Infrastructure (PKI)} for announcing the validity of X.509 certificates
in a domain. The current version of the service definition can be found
in 

\begin{itemize}
    \item RFC 5280 Internet X.509 Public Key Infrastructure Certificate
        and Certificate Revocation List (CRL) Profile
    \item RFC 6960 X.509 Internet Public Key Infrastructure Online
        Certificate Status Protocol (OCSP)
\end{itemize}

While CRL are signed list of all certificate revocations of the domain,
OCSP is an online status protocol that can be used by clients or 
during preprocessing by a delivery service, know as \emph{OCSP Stapling}.


% vi:set lbr breakindent:
